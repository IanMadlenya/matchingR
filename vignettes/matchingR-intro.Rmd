---
title: 'Matching Algorithms in R: An Introduction to matchingR'
author: '[Jan Tilly](mailto:jtilly@econ.upenn.edu) and [Nick Janetos](mailto:njanetos@econ.upenn.edu)'
date: "August 3, 2015"
output: html_document
bibliography: bibliography.bib
---
<!--
%\VignetteEngine{knitr::rmarkdown}  
%\VignetteIndexEntry{Matching algorithms in R: An introduction to matchingR}
%\usepackage[utf8]{inputenc}
-->

```{r, results = "hide", echo=FALSE, message = FALSE}
library(matchingR)
```

# Introduction

This package provides R functions to quickly compute stable matchings for large matching markets. It computes stable matchings for two-sided markets using the Gale-Shapley Algorithm [@gale1962college], and one-sided markets using [@irving1985roommates]'s algorithm. This package can be useful when the number of market participants is large or when very many matchings need to be computed (e.g. for extensive simulations or for estimation purposes). The package has successfully been used to simulate preferences and compute the matching with 30,000 participants on each side of the market. The package supports one-to-one, one-to-many, many-to-one, and one-sided matchings.  

Matching markets are very common in practice and widely studied by economists. Popular examples include

 * the National Resident Matching Program that matches recent graduates from medical school to residency programs at teaching hospitals throughout the United States
 * the matching of students to schools including the New York City High School or the the Boston Public School Match (and many more)
 * the matching of kidney donors to recipients in kidney exchanges.

# Two-sided matching markets

This package implements the the Gale-Shapley Algorithm to compute a stable matching for two-sided markets.

Consider the following example of the marriage market. Suppose there are `N` men and `N` women. A matching assigns men to women such that each man is assigned to exactly one woman and each woman is assigned to exactly one man. A matching is **stable** if there is no man `m` that would rather be matched to some other woman `w'` than to his current spouse `w` and this other woman `w'` would rather be matched to man `m` than to her current spouse `m'`. In other words, a matching is stable when there does not exist a pair `(m, w')` for which both `m` and `w'` are better off than they are with their respective spouses `w`  and `m'`.


## Preferences

We first need to introduce notation to specify men's and women's preferences. Men's payoffs from being matched are given by the payoff matrix `uM`. Columns in the matrix correspond to men, rows to women. For example: 
```{r}
uM = matrix(c(1.0, 0.5, 0.0,
              0.5, 0.0, 0.5,
              0.0, 1.0, 1.0), nrow = 3, ncol = 3, byrow = TRUE)
```
```{r, echo=FALSE}
dimnames(uM) = list(rows = c('Man 1', 'Man 2', 'Man 3'), cols = c('Woman 1', 'Woman 2', 'Woman 3'))
uM
```
In this example, man `1` receives a payoff of `1.0` from being matched to woman `1`, a payoff of `0.5` from being matched to woman `2` and a payoff of `0.0` from being matched to woman 3 (same logic applies to men `2` and `3`). Similarly, let the payoff matrix for women be given by
```{r}
uW = matrix(c(0.0, 1.0, 0.0,
              0.5, 0.0, 0.5,
              1.0, 0.5, 1.0), nrow = 3, ncol = 3, byrow = TRUE)
```
```{r, echo=FALSE}
dimnames(uW) = list(rows = c('Woman 1', 'Woman 2', 'Woman 3'), cols = c('Man 1', 'Man 2', 'Man 3'))
uW
```
Here, columns in the matrix correspond to women, rows to men. In this example, woman `1` receives a payoff of `0.0` from being matched to man `1`, a payoff of `0.5` from being matched to man `2` and a payoff of `1.0` from being matched to man 3 (same logic applies to women `2` and `3`).

Instead of using payoff matrices, we can also represent preferences using preference orderings. The preference ordering that corresponds to `uM` is
```{r}
prefM = matrix(c(1, 3, 3,
                 2, 1, 2,
                 3, 2, 1), nrow = 3, ncol = 3, byrow = TRUE)
```
```{r, echo=FALSE}
dimnames(prefM) = list(rows = c('Man 1', 'Man 2', 'Man 3'), cols = c('Woman 1', 'Woman 2', 'Woman 3'))
prefM
```
`prefM` states that man `1` prefers woman `1` over woman `2` over woman `3`, etc. The preference ordering that corresponds to `uW` is given by
```{r}
prefW = matrix(c(3, 1, 3,
                 2, 3, 2,
                 1, 2, 1), nrow = 3, ncol = 3, byrow = TRUE)
```
```{r, echo=FALSE}
dimnames(prefW) = list(rows = c('Woman 1', 'Woman 2', 'Woman 3'), cols = c('Man 1', 'Man 2', 'Man 3'))
prefW
```
The matching algorithm discussed below can take either payoff matrices of the type `uM` and `uW` or preference orderings of the type `prefM` and `prefW` as arguments.

## Gale-Shapley Algorithm: One-to-one matching

The Gale-Shapley algorithm works as follows: Single men ("the proposers") sequentially make proposals to each of their most preferred available women ("the reviewers"). A woman can hold on to at most one proposal at a time. A *single* woman will accept any proposal that is made to her. A woman that already holds on to a proposal will reject any proposal by a man that she values less than her current match. If a woman receives a proposal from a man that she values more than her current match, then she will accept the proposal and her previous match will join the line of bachelors. This process continues until all men are matched to women. 

For the preferences specified in `uM` and `uW`, we can compute the Gale-Shapley Algorithm by hand. Initially, all men are single. 

 1. * Man `1` proposes to woman `1`, his most-preferred choice.
    * Unmatched men: `2`, `3`
 2. * Man `2` proposes to woman `3`, his most-preferred choice. 
    * Unmatched men: `3`
 3. * Man `3` proposes to woman `3`, his most-preferred choice.
    * Woman `3` now dumps man `2`. 
    * Unmatched men: `2`
 4. * Man `2` proposes to woman `1`, his most-preferred available choice. 
    * Woman `1` now dumps man `1`. 
    * Unmatched men: `1`
 5. * Man `1` proposes to woman `2`, his most-preferred available choice. 
    * All men are now matched.
 
 The man-optimal stable matching is thefore:
 
 |-------|---------|
 | Man 1 | Woman 2 |
 | Man 2 | Woman 1 |
 | Man 3 | Woman 3 |

The package computes the Gale-Shapley algorithm using the function `one2one`:
```{r}
matching = one2one(uM, uW)
```
Note that we can obtain equivalent results when we use `prefM` and `prefW` as arguments:
```{r}
matching = one2one(proposerPref = prefM, reviewerPref = prefW)
```
The function `one2one` returns a list `matching` that includes the vectors `proposals` and `engagements` with the final proposals and engagements, respectively. These two vectors contain the same information (i.e. they tell us who is matched with whom). For the example above, the vector of proposals contains
```{r, echo=FALSE}
dimnames(matching$proposals) = list(rows = c("Man 1", "Man 2", "Man 3"), 
                                    cols = c("Proposed to Woman"))
```
```{r}
matching$proposals
```
The first element in the vector tells us that man `1` is matched with woman `2`. Man `2` is matched to woman `1`, and man `3` is matched to woman `3`. The vector of engagement contains 
```{r, echo=FALSE}
dimnames(matching$engagements) = list(rows = c("Woman 1", "Woman 2", "Woman 3"), 
                                      cols = c("Engaged to Man"))
```
```{r}
matching$engagements
```
The first element in the vector tells us that woman `1` is matched to man `2`, woman `2` will be matched to man `1`, and woman `3` will be matched to man `3`.

We can then check if the computed matching is stable using the function `checkStability`. To check if a matching is stable, we check for each assignment `(m,w)` if there is some other woman `w'` that man `m` would rather be matched with and who would rather be matched to man `m`. This function will return `true` if the matching is stable and `false` otherwise.
```{r, results = "hide", message=FALSE}
checkStability(uM, uW, matching$proposals, matching$engagements)
```
For the simple 3-by-3 example, we can perform this check by hand:

 * Man `1` is matched to woman `2`, his second-most preferred choice. His most preferred choice is woman `1`. Woman `1` is matched with man `2` who she prefers over man `1`. Thus man `1` cannot do better than woman `2`.
 * Man `2` is matched to woman `1`, his second-most preferred choice. His most preferred woman is woman `3`, who is     matched with man `3`. Since man `3` is her most-preferred choice, man `2` cannot do better than woman `1`.
 * Man `3` is matched to women `3`, his most preferred choice, so he cannot do better. 
 
Thus, this matching is stable.

## Extensions

The following examples illustrate some additional features of this package.

### Marriage Market with Unequal Number of Men and Women
The following is an example of `one2one` with different numbers of participants on each side of the market. There are 2,500 women and 2,000 men. By construction, 500 men will remain unmatched. We randomly generate payoff matrices `uM` and `uW` which are drawn from a uniform distribution (`runif`). We then compute the male-optimal (i.e. men are proposing) and the female-optimal (i.e. woman are proposing) matching.
```{r, results = "hide"}
# set seed
set.seed(1)
# set number of men
nmen = 2500
# set number of women
nwomen = 2000
# generate preferences
uM = matrix(runif(nmen*nwomen), nrow = nwomen, ncol = nmen) 
uW = matrix(runif(nmen*nwomen), nrow = nmen, ncol = nwomen) 
# male optimal matching
resultsM = one2one(uM, uW)
# female optimal matching
resultsW = one2one(uW, uM)
# check if matchings are stable
checkStability(uM, uW, resultsM$proposals, resultsM$engagements)
checkStability(uW, uM, resultsW$proposals, resultsW$engagements)
```

### College Admissions Problem: One-to-Many Matching
The following is an example of `one2many` where 1000 students get matched to 400 colleges, where each college has two slots. By construction, 200 students will remain unmatched. We draw students' and colleges' preferences, `uStudents` and `uColleges`, respectively, by from a uniform distribution. 
```{r, results = "hide"}
# set seed
set.seed(1)
# set number of students
nstudents = 1000
# set number of colleges
ncolleges = 400
# generate preferences
uStudents = matrix(runif(ncolleges*nstudents), nrow = ncolleges, ncol = nstudents) 
uColleges = matrix(runif(nstudents*ncolleges), nrow = nstudents, ncol = ncolleges) 
# worker optimal matching
results = one2many(uStudents, uColleges, slots = 2)
# check if matching is stable
checkStability(uStudents, uColleges, results$proposals, results$engagements)
```

# One-sided matching markets

This package implements [@irving1985roommates]'s algorithm for one-sided matching markets. 

Consider the following example: A set of $n$ potential roommates, each with ranked preferences over all the other potential roommates, are to be matched to rooms, two roommates per room. A matching is **stable** if there is no roommate `r1` that would rather be matched to some other roommate `d2` than to his current roommate `r2` and the other roommate `d2` would rather be matched to `r1` than to his current roommate `d1`. 

## Preferences

Preferences of potential roommates are summarized by an $n-1 \times n$ dimensional matrix, e.g., if $n = 6$, 
```{r}
pref = matrix(c(2, 5, 1, 4, 2, 4,
                3, 4, 3, 1, 0, 0,
                1, 3, 4, 2, 1, 2,
                5, 0, 0, 5, 3, 3,
                4, 2, 5, 0, 5, 1), nrow = 5, ncol = 6, byrow = TRUE)
```
Column $i$ represents the preferences of the $i$th roommate, and row $j$ represents the ranking of the roommate whose index is encoded in that row. For example, in the above preference matrix, roommate `0` most prefers to be matched with roommate `2`, followed by `3`, followed by `1`.

## [@irving1985roommates]'s algorithm

The algorithm proceeds in two phases.

### Phase 1

In phase 1, potential roommates take turns sequentially proposing to the other roommates. Each roommate who is proposed to can accept or reject the proposal. A roommate accepts if he currently has made no better proposal which was accepted to another roommate. If a roommate has accepted a proposal, and then receives a better proposal, he rejects the old proposal and substitutes in the new proposal. 

In the above example, 

1. Roommate `0` begins by proposing to roommate `2`, he most preferred roommate. `2`, having no better offers, accepts.
2. `1` proposes to `5`, who accepts.
3. `2` proposes to `1`, who accepts.
4. `3` proposes to `4`, who accepts.
5. `4` proposes to `2`, who accepts. `2` cancels his proposal from `0`.
6. `0`, having no proposal, proposes to `3`, who accepts.
7. `5` proposes to `4`, who rejects, having a better proposal from `3`.
8. `5` proposes to `0`, who accepts.

### Phase 2

In phase 2, we begin by eliminating all potential roommate matches which are worse than the current proposals held. For example, in the above example, `2` has a proposal from `4`, and so we eliminate `0` and `5` from `2`'s column, and symmetrically eliminate `2` from `0` and `5`'s column. This results in the following 'reduced' preference listing:
```
   5, 1, 4, 2,  
3, 4, 3, 1,    0
1, 3, 4, 2, 1,  
5, 0,    5, 3, 3
   2,    0,    1
```
These preferences form what is called a 'stable' table, or, 's-table'. ('Stable' for short.) The defining characteristic of a stable table is that if `i` is the most preferred roommate on `j`s list, then `j` is the least preferred roommate on `i`s list. For example, `0` most prefers `3`, but `3` least prefers `0`. 

The algorithm proceeds by finding and eliminating 'rotations'. A rotation is a sequence of pairs of roommates, such that there is a distinct roommate in the first position of each pair, the second roommate in each pair least prefers the roommate he is paired with, the first roommate in each pair most prefers the roommate he is paired with, and finally, the first roommate in each pair ranks the second roommate in the following pair second (modulo the number of pairs, that is, the first roommate in the last pair ranks the second roommate in the first pair second) Once a rotation has been identified, removing it results in another stable table.

For example, `(0, 3), (2, 1)` is a rotation in the above table, because `0` loves `3`, `2` loves `1`, `3` hates `0`, `1` hates `2`, `1` is second on `0`s list, and `3` is second on `2`'s list. Eliminating this rotation involves `1` rejecting `2`, `3` rejecting `0`, and then we remove every successive potential roommate as well to preserve the stable table property, resulting in
```
   5,    4, 2,  
   4, 3, 1,    0
1, 3, 4, 2, 1,  
5, 0,    5, 3, 3
               1
```
A further rotation is `(0, 1), (1, 5), (3, 4)`. Eliminating it yields
```
            2,  
   4, 3, 1,    0
   3, 4, 2, 1,  
5,              
```
A final rotation is `(1, 4), (2, 3)`. Eliminating it yields
```
            2,  
         1,    0
   3, 4,        
5,              
```
Therefore, a stable matching is for `0` and `5` to match, `1` and `3` to match, and `2` and `4` to match. 
```{r}
onesided(pref = pref)
```

# Literature
